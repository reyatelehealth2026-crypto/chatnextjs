
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Authentication Models (NextAuth.js)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?   @db.Text
  role          UserRole  @default(STAFF)
  lineAccountId String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])

  // Relations
  sentMessages        Message[]              @relation("SentMessages")
  assignedConversations ConversationAssignee[]
  createdNotes        CustomerNote[]
  pointsTransactions  PointsTransaction[]
  createdTemplates    Template[]
  createdRules        AutoReplyRule[]
  statusChanges       ConversationStatusHistory[]

  @@index([lineAccountId])
  @@index([email])
}

enum UserRole {
  OWNER
  ADMIN
  AGENT
  STAFF
  MARKETING
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Multi-Tenant Model
model LineAccount {
  id                String   @id @default(cuid())
  name              String
  lineChannelId     String   @unique
  lineChannelSecret String
  lineAccessToken   String
  webhookUrl        String?
  slaFirstResponse  Int      @default(300)  // seconds
  slaResolution     Int      @default(3600) // seconds
  timezone          String   @default("UTC")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  users             User[]
  customers         Customer[]
  conversations     Conversation[]
  templates         Template[]
  autoReplyRules    AutoReplyRule[]
  segments          Segment[]
  customFields      CustomField[]
  groups            Group[]
  broadcasts        Broadcast[]

  @@index([lineChannelId])
}

// Customer Models
model Customer {
  id              String   @id @default(cuid())
  lineAccountId   String
  lineUserId      String
  displayName     String
  pictureUrl      String?
  statusMessage   String?
  language        String?
  isBlocked       Boolean  @default(false)
  lastContactAt   DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  lineAccount     LineAccount @relation(fields: [lineAccountId], references: [id])

  // Relations
  conversations   Conversation[]
  tags            CustomerTag[]
  notes           CustomerNote[]
  pointsTransactions PointsTransaction[]
  customFieldValues  CustomFieldValue[]
  segmentMembers  SegmentMember[]

  @@unique([lineAccountId, lineUserId])
  @@index([lineAccountId])
  @@index([lineUserId])
  @@index([displayName])
}

model CustomerTag {
  id         String   @id @default(cuid())
  customerId String
  name       String
  color      String   @default("#3B82F6")
  createdAt  DateTime @default(now())

  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([name])
}

model CustomerNote {
  id         String   @id @default(cuid())
  customerId String
  content    String   @db.Text
  createdBy  String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  author     User     @relation(fields: [createdBy], references: [id])

  @@index([customerId])
  @@index([createdBy])
}

model PointsTransaction {
  id          String   @id @default(cuid())
  customerId  String
  amount      Int
  balance     Int
  type        PointsTransactionType
  description String?
  createdBy   String?
  createdAt   DateTime @default(now())

  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  admin       User?    @relation(fields: [createdBy], references: [id])

  @@index([customerId])
  @@index([createdAt])
}

enum PointsTransactionType {
  EARNED
  REDEEMED
  ADJUSTED
  EXPIRED
}

// Conversation Models
model Conversation {
  id              String             @id @default(cuid())
  lineAccountId   String
  customerId      String
  status          ConversationStatus @default(OPEN)
  lastMessageAt   DateTime           @default(now())
  firstResponseAt DateTime?
  resolvedAt      DateTime?
  closedAt        DateTime?
  satisfactionRating Int?
  satisfactionRatedAt DateTime?
  satisfactionRequestedAt DateTime?
  unreadCount     Int                @default(0)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  lineAccount     LineAccount @relation(fields: [lineAccountId], references: [id])
  customer        Customer    @relation(fields: [customerId], references: [id])

  // Relations
  messages        Message[]
  assignees       ConversationAssignee[]
  statusHistory   ConversationStatusHistory[]

  @@index([lineAccountId])
  @@index([customerId])
  @@index([status])
  @@index([lastMessageAt])
}

enum ConversationStatus {
  OPEN
  PENDING
  RESOLVED
  CLOSED
}

model ConversationAssignee {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  assignedAt     DateTime @default(now())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
}

model ConversationStatusHistory {
  id             String             @id @default(cuid())
  conversationId String
  fromStatus     ConversationStatus?
  toStatus       ConversationStatus
  changedBy      String
  changedAt      DateTime           @default(now())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [changedBy], references: [id])

  @@index([conversationId])
  @@index([changedAt])
}

// Message Models
model Message {
  id             String        @id @default(cuid())
  conversationId String
  content        String        @db.Text
  direction      MessageDirection
  senderId       String?
  lineMessageId  String?       @unique
  messageType    MessageType   @default(TEXT)
  metadata       Json?
  createdAt      DateTime      @default(now())

  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User?         @relation("SentMessages", fields: [senderId], references: [id])

  // Relations
  attachments    FileAttachment[]

  @@index([conversationId])
  @@index([createdAt])
  @@index([lineMessageId])
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  STICKER
  LOCATION
  FLEX
}

model FileAttachment {
  id          String   @id @default(cuid())
  messageId   String
  fileName    String
  fileSize    Int
  mimeType    String
  storageKey  String
  url         String?
  thumbnailUrl String?
  createdAt   DateTime @default(now())

  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

// Template & Automation Models
model Template {
  id            String   @id @default(cuid())
  lineAccountId String
  title         String
  content       String   @db.Text
  category      String?
  shortcuts     String[]
  variables     String[]
  usageCount    Int      @default(0)
  createdBy     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])
  author        User        @relation(fields: [createdBy], references: [id])

  @@index([lineAccountId])
  @@index([category])
}

model AutoReplyRule {
  id            String   @id @default(cuid())
  lineAccountId String
  name          String
  triggerType   TriggerType
  triggerValue  String
  responseContent String @db.Text
  isEnabled     Boolean  @default(true)
  priority      Int      @default(0)
  conditions    Json?
  usageCount    Int      @default(0)
  createdBy     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])
  author        User        @relation(fields: [createdBy], references: [id])

  @@index([lineAccountId])
  @@index([isEnabled])
  @@index([priority])
}

enum TriggerType {
  KEYWORD_EXACT
  KEYWORD_CONTAINS
  TIME_BASED
  FIRST_MESSAGE
}

// Segment Models
model Segment {
  id            String   @id @default(cuid())
  lineAccountId String
  name          String
  description   String?
  criteria      Json
  memberCount   Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])

  // Relations
  members       SegmentMember[]

  @@index([lineAccountId])
}

model SegmentMember {
  id         String   @id @default(cuid())
  segmentId  String
  customerId String
  addedAt    DateTime @default(now())

  segment    Segment  @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([segmentId, customerId])
  @@index([segmentId])
  @@index([customerId])
}

// Custom Fields
model CustomField {
  id            String   @id @default(cuid())
  lineAccountId String
  name          String
  fieldType     FieldType
  isRequired    Boolean  @default(false)
  options       String[]
  displayOrder  Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])

  // Relations
  values        CustomFieldValue[]

  @@index([lineAccountId])
  @@index([displayOrder])
}

enum FieldType {
  TEXT
  NUMBER
  DATE
  DROPDOWN
  CHECKBOX
}

model CustomFieldValue {
  id            String   @id @default(cuid())
  customFieldId String
  customerId    String
  value         String
  updatedAt     DateTime @updatedAt

  customField   CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)
  customer      Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([customFieldId, customerId])
  @@index([customFieldId])
  @@index([customerId])
}

// Group Chat Models
model Group {
  id            String   @id @default(cuid())
  lineAccountId String
  lineGroupId   String
  name          String
  pictureUrl    String?
  memberCount   Int      @default(0)
  lastMessageAt DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])

  // Relations
  members       GroupMember[]
  messages      GroupMessage[]

  @@unique([lineAccountId, lineGroupId])
  @@index([lineAccountId])
  @@index([lineGroupId])
}

model GroupMember {
  id          String   @id @default(cuid())
  groupId     String
  lineUserId  String
  displayName String
  pictureUrl  String?
  joinedAt    DateTime @default(now())

  group       Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, lineUserId])
  @@index([groupId])
}

model GroupMessage {
  id            String   @id @default(cuid())
  groupId       String
  lineUserId    String?
  content       String   @db.Text
  messageType   MessageType @default(TEXT)
  lineMessageId String?  @unique
  createdAt     DateTime @default(now())

  group         Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@index([createdAt])
}

// Broadcast Models
model Broadcast {
  id            String   @id @default(cuid())
  lineAccountId String
  name          String
  content       String   @db.Text
  targetType    BroadcastTargetType
  targetIds     String[]
  recipientCount Int     @default(0)
  sentCount     Int      @default(0)
  failedCount   Int      @default(0)
  status        BroadcastStatus @default(DRAFT)
  scheduledAt   DateTime?
  sentAt        DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  lineAccount   LineAccount @relation(fields: [lineAccountId], references: [id])

  @@index([lineAccountId])
  @@index([status])
  @@index([scheduledAt])
}

enum BroadcastTargetType {
  ALL
  SEGMENT
  CUSTOM
}

enum BroadcastStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  FAILED
}
